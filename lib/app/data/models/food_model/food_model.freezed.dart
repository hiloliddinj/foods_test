// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'food_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

FoodModel _$FoodModelFromJson(Map<String, dynamic> json) {
  return _FoodModel.fromJson(json);
}

/// @nodoc
mixin _$FoodModel {
  double? get clr => throw _privateConstructorUsedError;
  double? get prtn => throw _privateConstructorUsedError;
  double? get ft => throw _privateConstructorUsedError;
  double? get tcrb => throw _privateConstructorUsedError;
  double? get sgr => throw _privateConstructorUsedError;
  double? get gl => throw _privateConstructorUsedError;
  double? get clrj => throw _privateConstructorUsedError;
  double? get ncrb => throw _privateConstructorUsedError;
  List<String>? get als => throw _privateConstructorUsedError;
  String? get src => throw _privateConstructorUsedError;
  String? get sgm => throw _privateConstructorUsedError;
  String? get gr => throw _privateConstructorUsedError;
  String? get nm => throw _privateConstructorUsedError;
  MmtModel? get mmt => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $FoodModelCopyWith<FoodModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FoodModelCopyWith<$Res> {
  factory $FoodModelCopyWith(FoodModel value, $Res Function(FoodModel) then) =
      _$FoodModelCopyWithImpl<$Res, FoodModel>;
  @useResult
  $Res call(
      {double? clr,
      double? prtn,
      double? ft,
      double? tcrb,
      double? sgr,
      double? gl,
      double? clrj,
      double? ncrb,
      List<String>? als,
      String? src,
      String? sgm,
      String? gr,
      String? nm,
      MmtModel? mmt});

  $MmtModelCopyWith<$Res>? get mmt;
}

/// @nodoc
class _$FoodModelCopyWithImpl<$Res, $Val extends FoodModel>
    implements $FoodModelCopyWith<$Res> {
  _$FoodModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? clr = freezed,
    Object? prtn = freezed,
    Object? ft = freezed,
    Object? tcrb = freezed,
    Object? sgr = freezed,
    Object? gl = freezed,
    Object? clrj = freezed,
    Object? ncrb = freezed,
    Object? als = freezed,
    Object? src = freezed,
    Object? sgm = freezed,
    Object? gr = freezed,
    Object? nm = freezed,
    Object? mmt = freezed,
  }) {
    return _then(_value.copyWith(
      clr: freezed == clr
          ? _value.clr
          : clr // ignore: cast_nullable_to_non_nullable
              as double?,
      prtn: freezed == prtn
          ? _value.prtn
          : prtn // ignore: cast_nullable_to_non_nullable
              as double?,
      ft: freezed == ft
          ? _value.ft
          : ft // ignore: cast_nullable_to_non_nullable
              as double?,
      tcrb: freezed == tcrb
          ? _value.tcrb
          : tcrb // ignore: cast_nullable_to_non_nullable
              as double?,
      sgr: freezed == sgr
          ? _value.sgr
          : sgr // ignore: cast_nullable_to_non_nullable
              as double?,
      gl: freezed == gl
          ? _value.gl
          : gl // ignore: cast_nullable_to_non_nullable
              as double?,
      clrj: freezed == clrj
          ? _value.clrj
          : clrj // ignore: cast_nullable_to_non_nullable
              as double?,
      ncrb: freezed == ncrb
          ? _value.ncrb
          : ncrb // ignore: cast_nullable_to_non_nullable
              as double?,
      als: freezed == als
          ? _value.als
          : als // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      src: freezed == src
          ? _value.src
          : src // ignore: cast_nullable_to_non_nullable
              as String?,
      sgm: freezed == sgm
          ? _value.sgm
          : sgm // ignore: cast_nullable_to_non_nullable
              as String?,
      gr: freezed == gr
          ? _value.gr
          : gr // ignore: cast_nullable_to_non_nullable
              as String?,
      nm: freezed == nm
          ? _value.nm
          : nm // ignore: cast_nullable_to_non_nullable
              as String?,
      mmt: freezed == mmt
          ? _value.mmt
          : mmt // ignore: cast_nullable_to_non_nullable
              as MmtModel?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $MmtModelCopyWith<$Res>? get mmt {
    if (_value.mmt == null) {
      return null;
    }

    return $MmtModelCopyWith<$Res>(_value.mmt!, (value) {
      return _then(_value.copyWith(mmt: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_FoodModelCopyWith<$Res> implements $FoodModelCopyWith<$Res> {
  factory _$$_FoodModelCopyWith(
          _$_FoodModel value, $Res Function(_$_FoodModel) then) =
      __$$_FoodModelCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {double? clr,
      double? prtn,
      double? ft,
      double? tcrb,
      double? sgr,
      double? gl,
      double? clrj,
      double? ncrb,
      List<String>? als,
      String? src,
      String? sgm,
      String? gr,
      String? nm,
      MmtModel? mmt});

  @override
  $MmtModelCopyWith<$Res>? get mmt;
}

/// @nodoc
class __$$_FoodModelCopyWithImpl<$Res>
    extends _$FoodModelCopyWithImpl<$Res, _$_FoodModel>
    implements _$$_FoodModelCopyWith<$Res> {
  __$$_FoodModelCopyWithImpl(
      _$_FoodModel _value, $Res Function(_$_FoodModel) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? clr = freezed,
    Object? prtn = freezed,
    Object? ft = freezed,
    Object? tcrb = freezed,
    Object? sgr = freezed,
    Object? gl = freezed,
    Object? clrj = freezed,
    Object? ncrb = freezed,
    Object? als = freezed,
    Object? src = freezed,
    Object? sgm = freezed,
    Object? gr = freezed,
    Object? nm = freezed,
    Object? mmt = freezed,
  }) {
    return _then(_$_FoodModel(
      clr: freezed == clr
          ? _value.clr
          : clr // ignore: cast_nullable_to_non_nullable
              as double?,
      prtn: freezed == prtn
          ? _value.prtn
          : prtn // ignore: cast_nullable_to_non_nullable
              as double?,
      ft: freezed == ft
          ? _value.ft
          : ft // ignore: cast_nullable_to_non_nullable
              as double?,
      tcrb: freezed == tcrb
          ? _value.tcrb
          : tcrb // ignore: cast_nullable_to_non_nullable
              as double?,
      sgr: freezed == sgr
          ? _value.sgr
          : sgr // ignore: cast_nullable_to_non_nullable
              as double?,
      gl: freezed == gl
          ? _value.gl
          : gl // ignore: cast_nullable_to_non_nullable
              as double?,
      clrj: freezed == clrj
          ? _value.clrj
          : clrj // ignore: cast_nullable_to_non_nullable
              as double?,
      ncrb: freezed == ncrb
          ? _value.ncrb
          : ncrb // ignore: cast_nullable_to_non_nullable
              as double?,
      als: freezed == als
          ? _value._als
          : als // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      src: freezed == src
          ? _value.src
          : src // ignore: cast_nullable_to_non_nullable
              as String?,
      sgm: freezed == sgm
          ? _value.sgm
          : sgm // ignore: cast_nullable_to_non_nullable
              as String?,
      gr: freezed == gr
          ? _value.gr
          : gr // ignore: cast_nullable_to_non_nullable
              as String?,
      nm: freezed == nm
          ? _value.nm
          : nm // ignore: cast_nullable_to_non_nullable
              as String?,
      mmt: freezed == mmt
          ? _value.mmt
          : mmt // ignore: cast_nullable_to_non_nullable
              as MmtModel?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_FoodModel extends _FoodModel {
  const _$_FoodModel(
      {required this.clr,
      required this.prtn,
      required this.ft,
      required this.tcrb,
      required this.sgr,
      required this.gl,
      required this.clrj,
      required this.ncrb,
      required final List<String>? als,
      required this.src,
      required this.sgm,
      required this.gr,
      required this.nm,
      required this.mmt})
      : _als = als,
        super._();

  factory _$_FoodModel.fromJson(Map<String, dynamic> json) =>
      _$$_FoodModelFromJson(json);

  @override
  final double? clr;
  @override
  final double? prtn;
  @override
  final double? ft;
  @override
  final double? tcrb;
  @override
  final double? sgr;
  @override
  final double? gl;
  @override
  final double? clrj;
  @override
  final double? ncrb;
  final List<String>? _als;
  @override
  List<String>? get als {
    final value = _als;
    if (value == null) return null;
    if (_als is EqualUnmodifiableListView) return _als;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final String? src;
  @override
  final String? sgm;
  @override
  final String? gr;
  @override
  final String? nm;
  @override
  final MmtModel? mmt;

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_FoodModelCopyWith<_$_FoodModel> get copyWith =>
      __$$_FoodModelCopyWithImpl<_$_FoodModel>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_FoodModelToJson(
      this,
    );
  }
}

abstract class _FoodModel extends FoodModel {
  const factory _FoodModel(
      {required final double? clr,
      required final double? prtn,
      required final double? ft,
      required final double? tcrb,
      required final double? sgr,
      required final double? gl,
      required final double? clrj,
      required final double? ncrb,
      required final List<String>? als,
      required final String? src,
      required final String? sgm,
      required final String? gr,
      required final String? nm,
      required final MmtModel? mmt}) = _$_FoodModel;
  const _FoodModel._() : super._();

  factory _FoodModel.fromJson(Map<String, dynamic> json) =
      _$_FoodModel.fromJson;

  @override
  double? get clr;
  @override
  double? get prtn;
  @override
  double? get ft;
  @override
  double? get tcrb;
  @override
  double? get sgr;
  @override
  double? get gl;
  @override
  double? get clrj;
  @override
  double? get ncrb;
  @override
  List<String>? get als;
  @override
  String? get src;
  @override
  String? get sgm;
  @override
  String? get gr;
  @override
  String? get nm;
  @override
  MmtModel? get mmt;
  @override
  @JsonKey(ignore: true)
  _$$_FoodModelCopyWith<_$_FoodModel> get copyWith =>
      throw _privateConstructorUsedError;
}

MmtModel _$MmtModelFromJson(Map<String, dynamic> json) {
  return _MmtModel.fromJson(json);
}

/// @nodoc
mixin _$MmtModel {
  String? get u => throw _privateConstructorUsedError;
  double? get q => throw _privateConstructorUsedError;
  double? get s => throw _privateConstructorUsedError;
  double? get g => throw _privateConstructorUsedError;
  bool? get df => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MmtModelCopyWith<MmtModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MmtModelCopyWith<$Res> {
  factory $MmtModelCopyWith(MmtModel value, $Res Function(MmtModel) then) =
      _$MmtModelCopyWithImpl<$Res, MmtModel>;
  @useResult
  $Res call({String? u, double? q, double? s, double? g, bool? df});
}

/// @nodoc
class _$MmtModelCopyWithImpl<$Res, $Val extends MmtModel>
    implements $MmtModelCopyWith<$Res> {
  _$MmtModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? u = freezed,
    Object? q = freezed,
    Object? s = freezed,
    Object? g = freezed,
    Object? df = freezed,
  }) {
    return _then(_value.copyWith(
      u: freezed == u
          ? _value.u
          : u // ignore: cast_nullable_to_non_nullable
              as String?,
      q: freezed == q
          ? _value.q
          : q // ignore: cast_nullable_to_non_nullable
              as double?,
      s: freezed == s
          ? _value.s
          : s // ignore: cast_nullable_to_non_nullable
              as double?,
      g: freezed == g
          ? _value.g
          : g // ignore: cast_nullable_to_non_nullable
              as double?,
      df: freezed == df
          ? _value.df
          : df // ignore: cast_nullable_to_non_nullable
              as bool?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_MmtModelCopyWith<$Res> implements $MmtModelCopyWith<$Res> {
  factory _$$_MmtModelCopyWith(
          _$_MmtModel value, $Res Function(_$_MmtModel) then) =
      __$$_MmtModelCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? u, double? q, double? s, double? g, bool? df});
}

/// @nodoc
class __$$_MmtModelCopyWithImpl<$Res>
    extends _$MmtModelCopyWithImpl<$Res, _$_MmtModel>
    implements _$$_MmtModelCopyWith<$Res> {
  __$$_MmtModelCopyWithImpl(
      _$_MmtModel _value, $Res Function(_$_MmtModel) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? u = freezed,
    Object? q = freezed,
    Object? s = freezed,
    Object? g = freezed,
    Object? df = freezed,
  }) {
    return _then(_$_MmtModel(
      u: freezed == u
          ? _value.u
          : u // ignore: cast_nullable_to_non_nullable
              as String?,
      q: freezed == q
          ? _value.q
          : q // ignore: cast_nullable_to_non_nullable
              as double?,
      s: freezed == s
          ? _value.s
          : s // ignore: cast_nullable_to_non_nullable
              as double?,
      g: freezed == g
          ? _value.g
          : g // ignore: cast_nullable_to_non_nullable
              as double?,
      df: freezed == df
          ? _value.df
          : df // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_MmtModel extends _MmtModel {
  const _$_MmtModel(
      {required this.u,
      required this.q,
      required this.s,
      required this.g,
      required this.df})
      : super._();

  factory _$_MmtModel.fromJson(Map<String, dynamic> json) =>
      _$$_MmtModelFromJson(json);

  @override
  final String? u;
  @override
  final double? q;
  @override
  final double? s;
  @override
  final double? g;
  @override
  final bool? df;

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_MmtModelCopyWith<_$_MmtModel> get copyWith =>
      __$$_MmtModelCopyWithImpl<_$_MmtModel>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_MmtModelToJson(
      this,
    );
  }
}

abstract class _MmtModel extends MmtModel {
  const factory _MmtModel(
      {required final String? u,
      required final double? q,
      required final double? s,
      required final double? g,
      required final bool? df}) = _$_MmtModel;
  const _MmtModel._() : super._();

  factory _MmtModel.fromJson(Map<String, dynamic> json) = _$_MmtModel.fromJson;

  @override
  String? get u;
  @override
  double? get q;
  @override
  double? get s;
  @override
  double? get g;
  @override
  bool? get df;
  @override
  @JsonKey(ignore: true)
  _$$_MmtModelCopyWith<_$_MmtModel> get copyWith =>
      throw _privateConstructorUsedError;
}
